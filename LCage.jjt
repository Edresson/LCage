PARSER_BEGIN(LCage)
import java.io.*;
public class LCage {

public static void main(String args[]) throws ParseException,IOException {
    try{
        
		LCage parser = new LCage(new FileInputStream(args[0]));
        SimpleNode n = parser.LCage();
        n.dump("");

	}
	catch (Exception e) 
	{
		System.out.println( "Analise Sintaxica NOT OK");
		System.out.println("Erro de Token.");
		System.out.println(e.getMessage());
		e.printStackTrace(); 
	}
	catch (Error e)
	{
		System.out.println(e.getMessage()); //Mensagem de erro léxico (em ingles) mostrando linha e coluna
	}


    

  }
}

PARSER_END(LCage)


TOKEN_MGR_DECLS:
{
static int countLexError = 0;
int countParserError = 0;
public int foundLexError()
{
   return countLexError;
}
public int foundParserError()
{
   return countParserError;
}
}


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <COMENTARIO: "//" (<COM>)* >
| <COMENTARIOS: "/*" ("\n" | "\r" | <COM>)* "*/" >
| <#COM: ( ~["\"","\\","\n","\r","\""] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ( ["\n","\r"] | "\r\n") ) | "\"" )*>
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APARENT: "(">
| <FPARENT: ")">
| <VAR: "cage">
| <PTOVIRGULA: ";">
| <IF: "if">
| <WHILE: "ncage">
| <DO: "do">
| <RETURN: "return">
| <PRINT: "print">
| <FUNCAO: "funCage">
| <INT: "icage">
| <FLOAT: "fcage">
| <BOOL: "bcage">
| <TRUE: "true">
| <FALSE: "false">
| <VIRGULA: ",">
| <ATRIB: ":=">
}

TOKEN :
{
 <OP: ("+" | "-" | "*" | "/" )>
|<OPL: ( "<" | ">" | "=="| "<="| ">=" |"!")>
|<#LETRA: ["a"-"z","A"-"Z"]> 
|<#DIGITO: ["0"-"9"]>
|<#DIGITOS: <DIGITO>(<DIGITO>)*>
|<#LD: <LETRA> | <DIGITO>>
|<#FSUB: ("_"(<LD>)+)>
|<#FOP: ("."<DIGITOS>)?>
|<#EXPOP: ("E"("+"|"-")?<DIGITOS>)?>
|<IDENTIFICADOR: <LETRA>(<LD>)*(<FSUB>)*>
|<TOKEN_NUMLIT: <DIGITOS><FOP><EXPOP>>
}



// TRATANDO OS ERROS LEXICOS ENCONTRADOS
SPECIAL_TOKEN : {
 <ID_INVALIDO: ("@" | "!" | "#" | "*" | "-" | "+" "=" | "&" | <DIGITO>)(<LETRA>|<DIGITO> | "_" | "@")*>{
                                     System.out.println("IDENTIFICADOR: "+image);
                                     countLexError++;
                                     System.out.println("\u005cn\u005cnErro lexico -------->  Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" "+image +"\u005cn");
                                     }
|
<INVALIDO_LEXICO: 
(~["a"-"z",
"A"-"Z",
"0"-"9","\"","(",")","[","]","{","}",";",",",".","=",">","<","!","+","-","*","/","%"," ","\t","\n","\r","\f"
])+>{System.err.println("Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" Caractere invalido encontrado: " + image + "TOTAL ERRO "+countLexError);
                          countLexError++;
                          System.out.println("Erro Lexico --------> "+image);
                          System.out.println("\u005cn\u005cnErro lexico -------->  Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" "+image +"\u005cn");
                          }
|
<INVALID_CONST:
"\"" (~["\n","\r","\""])*["\n","\r"]>{System.err.println("Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" Caractere invalido encontrado \\n: " + image+" Era esperado uma aspa");
                                     countLexError++;
                                     System.out.println("Erro Lexico --------> "+image);
                                     System.out.println("\u005cn\u005cnErro lexico -------->  Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" "+image+"\u005cn");
                                     }
| <INVALID_CONSTANTE_CHAR: "\'" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\""] | ( ["\n","\r"] | "\r\n")))* "\'">{
                                     System.out.println("Erro lexico: --------> "+image);
                                     System.out.println("\u005cn\u005cnErro lexico: --------> "+image);
                                     }

}




SimpleNode LCage () :
{}
{ 

	Main() 
	(Func())*
	<EOF> 
{return jjtThis;}
}
	

void Main ():
{}
{
 <MAIN> <ACHAVES> 
 
 VarDecl()
 SeqComandos()

 <FCHAVES>

}

void Atribuicao():
{}
{
	 Atribuir()
	 | <PTOVIRGULA>  
}

void Mdeclaracao():
{}
{
 <VIRGULA> <IDENTIFICADOR> Atribuicao()
}


void VarDecl ():
{}
{
	(<VAR> Tipo() <IDENTIFICADOR> Atribuicao())* 
}

void Tipo ():
{}
{
	<INT> | <BOOL> | <FLOAT>
}

void SeqComandos ():
{}
{
	(Comando())*
}

void Comando ():
{}
{
	<IDENTIFICADOR> Atribuir() | <IF> <APARENT> Exp_logicas() <FPARENT> <ACHAVES> SeqComandos() <FCHAVES> <PTOVIRGULA> 
						| <WHILE> <APARENT> Exp_logicas() <FPARENT> <ACHAVES> SeqComandos() <FCHAVES> <PTOVIRGULA>
						| <DO> <ACHAVES> SeqComandos() <FCHAVES> <WHILE> <APARENT> Exp_logicas() <FPARENT> <PTOVIRGULA>
						| <RETURN> Exp() <PTOVIRGULA>
						| <PRINT> <APARENT> Exp() <FPARENT> <PTOVIRGULA>

}

void Atribuir ():
{}
{
	<ATRIB> Exp() Loop()  | <APARENT> ( ListaExp() )? <FPARENT> <PTOVIRGULA>| Mdeclaracao() 
}


void Loop():
{}
{
	 Mdeclaracao() | <PTOVIRGULA>
}	
// expressões 
void Exp():
{}
{
	<APARENT> Exp() <OP> Exp() <FPARENT> | Fator()
}

void Fator():
{}
{
	<IDENTIFICADOR> ( <APARENT> ( ListaExp() )? <FPARENT> )? | <TOKEN_NUMLIT> | <TRUE> | <FALSE>
}

void ListaExp():
{}
{
	Exp() ListaExp2()
}

void ListaExp2():
{}
{
	(<VIRGULA> Exp() ListaExp2())?
}
// expressões logicas
void Exp_logicas():
{}
{
	<APARENT> Exp_logicas() <OPL> Exp_logicas() <FPARENT> | Fator_logico()
}

void Fator_logico():
{}
{
	<IDENTIFICADOR> ( <APARENT> ( ListaExp_logico() )? <FPARENT> )? | <TOKEN_NUMLIT> | <TRUE> | <FALSE>
}


void ListaExp_logico():
{}
{
	Exp_logicas() ListaExp2()
}

void ListaExp2_logico():
{}
{
	(<VIRGULA> Exp_logicas() ListaExp2_logico())?
}



void Func():
{}
{
	<FUNCAO> Tipo() <IDENTIFICADOR> <APARENT> ( ListaArg() )? <FPARENT> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>
}

void ListaArg():
{}
{
	Tipo() <IDENTIFICADOR> ListaArg2()
}

void ListaArg2():
{}
{
	(<VIRGULA> Tipo() <IDENTIFICADOR> ListaArg2())?
}