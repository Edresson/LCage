/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. LCage.jj */
/*@egen*/PARSER_BEGIN(LCage)
import java.io.*;
public class LCage/*@bgen(jjtree)*/implements LCageTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTLCageState jjtree = new JJTLCageState();

/*@egen*/

public static void main(String args[]) throws ParseException,IOException {
    try{
        
		LCage parser = new LCage(new FileInputStream(args[0]));
        SimpleNode n = parser.LCage();
        n.dump("");

	}
	catch (Exception e) 
	{
		System.out.println( "Analise Sintaxica NOT OK");
		System.out.println("Erro de Token.");
		System.out.println(e.getMessage());
		e.printStackTrace(); 
	}
	catch (Error e)
	{
		System.out.println(e.getMessage()); //Mensagem de erro l\u00e9xico (em ingles) mostrando linha e coluna
	}


    

  }
}

PARSER_END(LCage)


TOKEN_MGR_DECLS:
{
static int countLexError = 0;
int countParserError = 0;
public int foundLexError()
{
   return countLexError;
}
public int foundParserError()
{
   return countParserError;
}
}


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <COMENTARIO: "//" (<COM>)* >
| <COMENTARIOS: "/*" ("\n" | "\r" | <COM>)* "*/" >
| <#COM: ( ~["\"","\\","\n","\r","\""] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ( ["\n","\r"] | "\r\n") ) | "\"" )*>
}

TOKEN :
{
  <      MAIN: 	"main"		>
| <	  ACHAVES: 	"{"			>
| <	  FCHAVES: 	"}"			>
| <	  APARENT: 	"("			>
| <	  FPARENT: 	")"			>
| <	      VAR: 	"cage"		>
| <PTOVIRGULA: 	";"			>
| <		   IF: 	"cageif"	>
| <		 ELSE: 	"elcages"	>
| <		WHILE: 	"ncage"		>	
| <		   DO: 	"docage"	>
| <    RETURN: 	"recage"	>
| <     PRINT: 	"pricage"	>
| <    FUNCAO:  "funCage"	>
| <		  INT:  "icage"		>
| <     FLOAT: 	"fcage"		>
| <      BOOL:  "bcage"		>
| <		 TRUE: 	"trucage"	>
| <		FALSE: 	"falcage"	>
| <	  VIRGULA: 	","			>
| <		ATRIB: 	":="		>
}

TOKEN :
{
 <			 OP: ("+" | "-" | "*" | "/" )					>
|<		    OPL: ( "<" | ">" | "=="| "<="| ">=" |"!")		>
|<		 #LETRA: ["a"-"z","A"-"Z"]							> 
|<	    #DIGITO: ["0"-"9"]									>
|<	   #DIGITOS: <DIGITO> (<DIGITO>)*						>
|<		    #LD: <LETRA> | <DIGITO>							>
|<		  #FSUB: ("_"(<LD>)+)								>
|<		   #FOP: ("."<DIGITOS>)?							>
|<		 #EXPOP: ("E"("+" | "-")?<DIGITOS>)?				>
|<IDENTIFICADOR: <LETRA>(<LD>)*(<FSUB>)*					>
|< TOKEN_NUMLIT: <DIGITOS><FOP><EXPOP>						>
}



// TRATANDO OS ERROS LEXICOS ENCONTRADOS
SPECIAL_TOKEN : {
	<ID_INVALIDO: ("@" | "!" | "#" | "*" | "-" | "+" "=" | "&" | <DIGITO>)(<LETRA>|<DIGITO> | "_" | "@")*>{
		System.out.println("Identificador Invalido: "+image);
		countLexError++;
		System.out.println(
			"\n\nErro lexico -------->  Linha "+
			 input_stream.getEndLine()+
			 " Coluna "+ 
			 input_stream.getEndColumn()+
			 " "+
			 image+
			 "\n"
		);
	}
|
<INVALIDO_LEXICO: 
(~["a"-"z",
"A"-"Z",
"0"-"9","\"","(",")","{","}",";",",",".","=",":",">","<","!","+","-","*","/"," ","_",";","\t","\n","\r","\f"
])+>{System.out.println("Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" Caractere invalido encontrado: " + image + "TOTAL ERRO "+countLexError);
                          countLexError++;
                          System.out.println("\n\nErro lexico -------->  Linha "+ input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+" "+image +"\n");
                          }
}




SimpleNode LCage () :
{/*@bgen(jjtree) LCage */
  SimpleNode jjtn000 = new SimpleNode(JJTLCAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LCage */
        try {
/*@egen*/ 

	Main() 
	(Func())*
	<EOF>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
	
// Define a fun\u00e7\u00e3o main do programa
void Main ():
{/*@bgen(jjtree) Main */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
 try {
/*@egen*/
 <MAIN> <ACHAVES> 
 
 VarDecl()
 SeqComandos()

 <FCHAVES>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}

//Declara\u00e7\u00f5es de variaveis
void VarDecl ():
{/*@bgen(jjtree) VarDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
        try {
/*@egen*/
	(<VAR> Tipo() <IDENTIFICADOR> Atribuicao())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Tipo ():
{/*@bgen(jjtree) Tipo */
  SimpleNode jjtn000 = new SimpleNode(JJTTIPO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Tipo */
        try {
/*@egen*/
	<INT> | <BOOL> | <FLOAT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// Deriva em atribuir ou adiciona ponto e virgula
void Atribuicao():
{/*@bgen(jjtree) Atribuicao */
  SimpleNode jjtn000 = new SimpleNode(JJTATRIBUICAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Atribuicao */
         try {
/*@egen*/
	 Atribuir()
	 | <PTOVIRGULA>/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/  
}

// Atribui  uma express\u00e3o a uma variavel, uma express\u00e3o  (( 1+1 )), ou deriva em Mdeclaracao permitindo  multiplas declara\u00e7\u00f5es
void Atribuir ():
{/*@bgen(jjtree) Atribuir */
  SimpleNode jjtn000 = new SimpleNode(JJTATRIBUIR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Atribuir */
        try {
/*@egen*/
	<ATRIB> Exp() Loop()  | <APARENT> ( ListaExp() )? <FPARENT> <PTOVIRGULA> | Mdeclaracao()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

// Adiciona virgula a atribuicao permitindo multipla declara\u00e7\u00e3o do tipo: var fcage a,b,c;
void Mdeclaracao():
{/*@bgen(jjtree) Mdeclaracao */
  SimpleNode jjtn000 = new SimpleNode(JJTMDECLARACAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Mdeclaracao */
 try {
/*@egen*/
 <VIRGULA> <IDENTIFICADOR> Atribuicao()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// adiciona mais uma atribuicao na mesma linha ex: var icage a:=1,b:=2;
void Loop():
{/*@bgen(jjtree) Loop */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Loop */
         try {
/*@egen*/
	 Mdeclaracao() | <PTOVIRGULA>/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}	


// uma express\u00e3o matematica entre parenteses ou deriva em Fator
void Exp():
{/*@bgen(jjtree) Exp */
  SimpleNode jjtn000 = new SimpleNode(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exp */
        try {
/*@egen*/
	<APARENT> Exp() <OP> Exp() <FPARENT> | Fator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// gera uma chamada de fun\u00e7\u00e3o ou  um numero ou  true ou false
void Fator():
{/*@bgen(jjtree) Fator */
  SimpleNode jjtn000 = new SimpleNode(JJTFATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Fator */
        try {
/*@egen*/
	<IDENTIFICADOR> ( <APARENT> ( ListaExp() )? <FPARENT> )? | <TOKEN_NUMLIT> | <TRUE> | <FALSE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
// uma Exp e derivando em ListaExp2 
void ListaExp():
{/*@bgen(jjtree) ListaExp */
  SimpleNode jjtn000 = new SimpleNode(JJTLISTAEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListaExp */
        try {
/*@egen*/
	Exp() ListaExp2()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// permite usar virgula nos parametros das funcoes nas declara\u00e7\u00e3o exp: cage fcage b := func(a,b)
void ListaExp2():
{/*@bgen(jjtree) ListaExp2 */
  SimpleNode jjtn000 = new SimpleNode(JJTLISTAEXP2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListaExp2 */
        try {
/*@egen*/
	(<VIRGULA> Exp() ListaExp2())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


// ap\u00f3s as declara\u00e7\u00f5es de variaveis usa-se essa fun\u00e7\u00e3o para criar os loops,condicionais entre outros.
void SeqComandos ():
{/*@bgen(jjtree) SeqComandos */
  SimpleNode jjtn000 = new SimpleNode(JJTSEQCOMANDOS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SeqComandos */
        try {
/*@egen*/
	(Comando())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
// pode-se atribuir um valor a uma variavel  ex: a := (1 + 1);
//declarar estrutura condicional, comando de repeticao do tipo NCAGE, e do tipo DOCAGE
// Retornar valor , e usar a fun\u00e7\u00e3o de mostrar na tela (PRINT)
void Comando ():
{/*@bgen(jjtree) Comando */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMANDO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Comando */
                try {
/*@egen*/
		<IDENTIFICADOR> Atribuir() 
		| <IF> <APARENT> Exp_logicas() <FPARENT><ACHAVES>SeqComandos()<FCHAVES> (<ELSE> <ACHAVES>SeqComandos()<FCHAVES>)? <PTOVIRGULA>
		| <WHILE> <APARENT> Exp_logicas() <FPARENT><ACHAVES>SeqComandos()<FCHAVES> <PTOVIRGULA>
		| <DO> <ACHAVES>SeqComandos()<FCHAVES> <WHILE> <APARENT> Exp_logicas() <FPARENT> <PTOVIRGULA>						
		| <RETURN> Exp() <PTOVIRGULA>
		| <PRINT> <APARENT> Exp() <FPARENT> <PTOVIRGULA>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}
//fun\u00e7\u00e3o recursiva para auxiliar a chamada de v\u00e1rios if else                                                       



//  uma express\u00e3o logica entre parenteses ou deriva em Fator_logico
void Exp_logicas():
{/*@bgen(jjtree) Exp_logicas */
  SimpleNode jjtn000 = new SimpleNode(JJTEXP_LOGICAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exp_logicas */
        try {
/*@egen*/
	<APARENT> Exp_logicas() <OPL> Exp_logicas() <FPARENT> | Fator_logico()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// gera um identificador  ou  um numero ou  true ou false

void Fator_logico():
{/*@bgen(jjtree) Fator_logico */
  SimpleNode jjtn000 = new SimpleNode(JJTFATOR_LOGICO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Fator_logico */
        try {
/*@egen*/
	<IDENTIFICADOR> | <TOKEN_NUMLIT> | <TRUE> | <FALSE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



//declara fun\u00e7\u00f5es
void Func():
{/*@bgen(jjtree) Func */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Func */
        try {
/*@egen*/
	<FUNCAO> Tipo() <IDENTIFICADOR> <APARENT> ( ListaArg() )? <FPARENT> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//lista de argumentos da fun\u00e7\u00e3o, permitindo declara\u00e7\u00f5es mas n\u00e3o um valor default para o parametro
void ListaArg():
{/*@bgen(jjtree) ListaArg */
  SimpleNode jjtn000 = new SimpleNode(JJTLISTAARG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListaArg */
        try {
/*@egen*/
	Tipo() <IDENTIFICADOR> ListaArg2()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// adiciona virgula para os argumentos da fun\u00e7\u00e3o
void ListaArg2():
{/*@bgen(jjtree) ListaArg2 */
  SimpleNode jjtn000 = new SimpleNode(JJTLISTAARG2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListaArg2 */
        try {
/*@egen*/
	(<VIRGULA> Tipo() <IDENTIFICADOR> ListaArg2())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}